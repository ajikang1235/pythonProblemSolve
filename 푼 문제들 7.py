

# 내가 푼 문제 아니다. 진짜 참고용

'''
게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다.
(위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다.
모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다.
게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다.
집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다.
다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.


만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다.
위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다.
 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때,
크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

[제한사항]
board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.
board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
0은 빈 칸을 나타냅니다.
1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
moves 배열의 크기는 1 이상 1,000 이하입니다.
moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

입출력 예
board	                                                        moves	            result
[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]	[1,5,3,5,1,2,1,4]	4

입출력 예 #1

인형의 처음 상태는 문제에 주어진 예시와 같습니다.
크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후,
상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.

'''


def solution(board,moves):

    answer=[]
    basket_list=[]
    for i in moves:
        for j in range(len(board)):
            if board[j][i-1]>0:
                basket_list.append(board[j][i-1])
                board[j][i-1]=0
                if basket_list[-1:]==basket_list[-2:-1]:
                    answer+=basket_list[-1:]
                    basket_list=basket_list[:-2]
                break
    return len(answer)*2




print(solution([[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]],[1,5,3,5,1,2,1,4]))





'''
문제 설명
문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. 
str에 나타나는 숫자 중 최소값과 최대값을 찾아 
이를 (최소값) (최대값)형태의 문자열을 반환하는 함수, solution을 완성하세요.
예를들어 s가 1 2 3 4라면 1 4를 리턴하고, -1 -2 -3 -4라면 -4 -1을 리턴하면 됩니다.

제한 조건
s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.

입출력 예
s	                return
'1 2 3 4'	        '1 4'
'-1 -2 -3 -4'	    '-4 -1'
'-1 -1'	            '-1 -1'
'''


def solution(s):
    answer=''
    s=s.split()            # 문자열을 공백을 기준으로 리스트로 변환하는 함수
    value=[int(e) for i,e in enumerate(s)]   # 인덱스값이 아니라 실제 값을 축출하고 정수형으로 캐스팅한 리스트 생성
    small_value=min(value)                   # 그 리스트 중에 제일 작은 값
    big_value=max(value)                     # 그 리스트 중에 제일 큰 값

    sort_add=str(small_value)+' '+str(big_value)   # 최솟값 - 공백 - 최댓값 순으로 나열한 뒤,  각각 문자열로 캐스팅
    answer+=sort_add                               # 결과 값 반환
    return answer


print(solution('1 2 3 4'))


# enumerate 함수를 사용해보았다. 다른 풀이를 볼 때, list 사용도 있지만, enumerate를 한번 활용해보고 싶었다.
# 변수 사용이 좀 많은 것이 흠이나, 변수 사용은 코딩에 안전성을 제고해준다.
# 단, 안전성을 담보하는 만큼 속도 면에서는 느리다는 측면은 감안해야 한다.


# 리스트 반복문 작성 시 변수 입력시 i+1==i와 같은 조건무은 먹히지 않는다.


'''
문제 설명
어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 AB는 1만큼 밀면 BC가 되고, 3만큼 밀면 DE가 됩니다. z는 1만큼 밀면 a가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

제한 조건
공백은 아무리 밀어도 공백입니다.
s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.
s의 길이는 8000이하입니다.
n은 1 이상, 25이하인 자연수입니다.
입출력 예
s	    n	result
'AB'	1	'BC'
'z'	    1	'a'
'a B z'	4	'e F d'
'''



def solution(s,n):


    daeMun='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    soMun='abcdefghijklmnopqrstuvwxyz'
    answer=""


    for idx in s:                       # s의 인덱스를 축출
        if idx in soMun:                # 동일변수를 소문자열에서 속해 있는지 확인한다.
            com_idx=soMun.find(idx)+n   # 변수를 만들어서 find 함수가 거르는 인덱스 번호와 밀어낸 n의 값만큼을 더한다
            answer+=soMun[com_idx%26]   # 문자열 길이를 넘지 않기 위해 [변수%열 총길이]
        elif idx in daeMun:             # 동일변수를 대문자열에 속해 있는지 확인한다.
            com_idx2=daeMun.find(idx)+n #위 과정과 동일
            answer+=daeMun[com_idx2%26]
        else:
            answer += " "               # 공백일 경우 결과값에 공백 하나씩 추가
    return answer

print(solution('a  B',1))



# 원 문제는 아스키 코드값을 응용한 함수가 쓰였으나, 아직 쓰임이 익숙치 않아. 좀 더 익숙한 방법을 참고했다.
# 인덱스의 길이문제에 걸리지 않기 위해서
# [변수(매개변수)% 열(컨테이너)의 총 길이]를 많이 쓴다. 이 부분도 잘 기억해두자.
# [%] 이 부분은 따로 뭐라고 설명을 해야할까...



'''
Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.



Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.

Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때
카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한사항
갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.

입출력 예
brown	yellow	return
10	    2	    [4, 3]
8	    1	    [3, 3]
24	    24	    [8, 6]
'''


def solution(brown, yellow):
    answer=[]
    for i in range(1,yellow+1):
        if yellow%i==0:
            answer.append(i)
    for j in range(len(answer)//2+1):
        if (answer[j]+2)*(answer[-j-1]+2)-yellow==brown:
           return [answer[-j - 1] + 2, answer[j] + 2]





print(solution(10,2))

# 완전 탐색이라고 다 길게 하는 건 아닌가봄
# 수학 능지가 매우 처참하다.



'''
2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요?
두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요.
요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT

입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.

제한 조건
2016년은 윤년입니다.
2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)

입출력 예
a	b	result
5	24	'TUE'
'''

import datetime

def solution(a,b):
    days=['MON','TUE','WED','THU','FRI','SAT','SUN']   # 날짜 리스트 작성
    dt=datetime.datetime(2016,a,b)                     # datetime 은 날짜를 지정하는 함수
    dt2=dt.weekday()                                   # 그 날짜의 요일을 숫자로 나타내는 weekday() 함수, 화요일은 1
    result=days[dt2]                                   # 숫자에 맞춰 슬라이싱한 날짜를 결과값에 반환.
    return result

print(solution(2,25))


# weekday() 함수는 요일을 숫자로 나타내주는 함수이다.
# 0 - 월요일
# 1 - 화요일
# 2 - 수요일
# 3 - 목요일
# 4 - 금요일
# 5 - 토요일
# 6 - 일요일
# 리스트의 슬라이싱 위치와 weekday() 함수의 숫자값에 해당하는 요일이 같다.
# datetime 함수는 특정한 인수가 나오지 않은 이상, 잘 안쓰지 않을까 싶다.
