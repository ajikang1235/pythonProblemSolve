

# 논란의 여지가 있는 문제이다. 인덱싱해서 풀 수 있는 문제라면, 뭐하러 해쉬 카데고리로 분류하는지 의문이다.

'''
전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

구조대 : 119
박준영 : 97 674 223
지영석 : 11 9552 4421

전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때,
어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

제한 사항
phone_book의 길이는 1 이상 1,000,000 이하입니다.
각 전화번호의 길이는 1 이상 20 이하입니다.

phone_book	                            return
['119', '97674223', '1195524421']	    false
['123','456','789']	                    true
['12','123','1235','567','88']	        false

'''


def solution(phone_book):
    phone_book.sort()
    for a in range(len(phone_book)-1):            # 정렬된 리스트 인에 앞의 2개의 값만 비교해보면 알 수있다
        if phone_book[a] in phone_book[a+1] :     # a의 문자열이 a+1의 문자열에 있는지 확인해보기
            return False
    return True


print(solution(['119','97674223','1195524421']))

# 해쉬란, 데이터를 저장할 공간을 창출함을 통해 빠르게 검색ㅇ 가능하게끔 만드는 알고리즘이다.
# 위의 코드는 별로 해쉬의 취지에 맞지 않게 나왔다. 따라서 아래 코드를 참조하는게 더 좋다.



def solution(phone_book):
    answer = True
    hash_map = {}
    for phone_number in phone_book:
        hash_map[phone_number] = 1
    for phone_number in phone_book:
        temp = ""
        for number in phone_number:
            temp += number
            if temp in hash_map and temp != phone_number:
                answer = False
    return answer


# 참고용
no_list=[1,3,4,5,'메시',6]
no_dict={}
for i in no_list:
    no_dict[i]=1        # 값을 입력하는 키
    print(no_dict)




'''
문제 설명
두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다.
예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다.
n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.

제한 사항
arr은 길이 1이상, 15이하인 배열입니다.
arr의 원소는 100 이하인 자연수입니다.

arr	        result
[2,6,8,14]	168
[1,2,3]	    6

'''

import math

def solution(arr):
    lcm=arr[0]                          # 배열의 1번째 값을 디폴트로 고정
    for i in arr[1:]:                   # 배열의 1번째 값 다음의 숫자들을 반복시켜줌
        lcm=int(lcm*i/math.gcd(lcm,i))  # 최소공배수(n개의 모든 숫자들의 곱/ n개의 모든 숫자드르이 최대공약수)
    return lcm


print(solution([2,6,8,14]))

# 생각보다 문제를 어렵게 풀었었다.
# 최소공배수만 구하면 되는 문제인데..



'''
문제 설명
길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.
배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며,
두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다.
(단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)

예를 들어 A = [1, 4, 2] , B = [4, 5, 4] 라면

A에서 첫번째 숫자인 1, B에서 두번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)
A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)
A에서 세번째 숫자인 2, B에서 첫번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)
즉, 이 경우가 최소가 되므로 29를 return 합니다.

배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.

제한사항
배열 A, B의 크기 : 1,000 이하의 자연수
배열 A, B의 원소의 크기 : 1,000 이하의 자연수


입출력 예
A	        B	        answer
[1, 4, 2]	[4, 5, 4]	29
[1,2]	    [3,4]	    10


입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
A에서 첫번째 숫자인 1, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다.
(누적된 값 : 4) 다음, A에서 두번째 숫자인 2, B에서 첫번째 숫자인 3을 뽑아 곱하여 더합니다. (누적된 값 : 4 + 6 = 10)
이 경우가 최소이므로 10을 return 합니다.
'''


def solution(A,B):

    A.sort()
    B.sort(reverse=True)
    c=0

    for i,v in zip(A,B):
        c+=i*v
    return c

print(solution([1,4,2],[5,4,4]))

# 문제 의도가 잘 파악이 안됨
# 정렬을 사용하는 이유가 뭔지 모르겠음
# zip함수는 2개의 컨테이너가 있을 때, 인덱스에 해당하는 값끼리만 도출해주는 함수이다.
# enumerate / zip 함수는 알아두자.


'''
문제 설명
길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요.

이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이)

제한사항
a, b의 길이는 1 이상 1,000 이하입니다.
a, b의 모든 수는 -1,000 이상 1,000 이하입니다.
입출력 예
a	        b	            result
[1,2,3,4]	[-3,-1,0,2]	    3
[-1,0,1]	[1,0,-1]	    -2

'''

def solution(a,b):
    answer=0
    while len(a)==len(b):
        for i in range(len(a)):
            for j in range(len(b)):
                if i==j:                    # 자릿값 같을때 곱해서 answer에 추가해주기
                    answer+=a[i]*b[j]
        return answer

print(solution([-1,0,1],[1,0,-1]))

# 엄청 쉬운 문제, 사실상 문제에 답이 다 있음
# 다만, zip 함수를 썼으면 좀 더 빨리 풀었을 수도 있었다. 2개의 배열이 나올때  zip 함수 사용을 고려해보자.



'''
문제 설명
프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고,
이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와
각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

제한 사항
작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
작업 진도는 100 미만의 자연수입니다.
작업 속도는 100 이하의 자연수입니다.
배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다.
예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

입출력 예
progresses	                speeds	            return
[93, 30, 55]	            [1, 30, 5]      	[2, 1]
[95, 90, 99, 99, 80, 99]	[1, 1, 1, 1, 1, 1]	[1, 3, 2]

입출력 예 설명

입출력 예 #1
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다.
하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

입출력 예 #2
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다.
어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.

따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.
'''




def solution(progresses,speeds):
    answer=[]

    while progresses:                  # 반복시키기 위해서 progresses 를 while 문에 입력
        for i in range(len(progresses)):
            progresses[i]+=speeds[i]   # progresses와 speeds의 각 요소의 합이 100이 되게끔 반복
        cnt=0                          # front 에 해당하는  SP 설정
        while progresses and progresses[0] >= 100:  # 반복을 돌리기 위해  progresses 설정하고  첫번째 인덱스가 100을 넘으면
            progresses.pop(0)                       # 제일 왼쩍에 있는 요소를 빼준다. FIFO 방식.
            speeds.pop(0)                           # 기능이 다 개발되었으니 스피드도 더 이상 필요가 없다.
            cnt+=1                                  # SP 를 하나씩 올린다.

        if cnt!=0:
            answer.append(cnt)                      # 빈 리스트에 SP 횟수 추가

    return answer




print(solution([98,99,22],[5,1,30]))


# 본 문제는 queue 방식인데, class를 지정하지 않고 쓰는 문제라, 아직은 낯설다.
# 혹여 모르니 반복문을 돌리기 위해서 리스트 자체를 while문에 돌리는 법을 잊지 말자.