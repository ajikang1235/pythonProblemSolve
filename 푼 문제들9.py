'''
문제 설명
초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때,
가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

제한사항
prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
prices의 길이는 2 이상 100,000 이하입니다.

입출력 예
prices	        return
[1, 2, 3, 2, 3]	[4, 3, 1, 1, 0]
입출력 예 설명
1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.
2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.
3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.
5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.
'''


from collections import deque

def solution(prices):
    answer=[]
    prices=deque(prices)           # 주식가격표 일람을 deque 로 큐하기 편리하게 변환

    while prices:
        a=prices.popleft()         # 제일 왼쪽에 먼저 들어간 데이터 빼내기
        top=0                      # 데이터 비교 시 추가할 SP 설정

        for i in prices:           # prices 안의 요소들 반복시켜서
            if a>i:                # 먼저 빼낸 데이터와 요소들의 크기 비교해 먼저 데이터가 요소보다 크다면 (가격이 떨어진다면)
                top+=1             # 하나를 추가해 떨어진 시간까지 반복해서 1 추가 후
                break              # 빠져나온다
            top+=1                 # 떨어진 시간이 나올때까지 1을 추가한다. 떨어지지 않으면
                                   # len(prices)-1 까지의 숫자만큼 가격이 유지되니, 1이 계속 추가된다.
        answer.append(top)         # answer 에 포함

    return answer


print(solution([1,1,3,4,2,1]))

# Queue 의 방식으로 생각했고, 그게 맞았으나 구현이 잘 안되서 참고했다.
# stack 이나 queue 를 풀 때, 입출력 차이의 방식을 상기해보자.
# while 문 사용을 잘 활용해보자.



'''
JadenCase 문자열 만들기
문제 설명
JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다.
문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.

제한 조건
s는 길이 1 이상인 문자열입니다.
s는 알파벳과 공백문자(" ")로 이루어져 있습니다.
첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 )


입출력 예
s	                    return
'3people unFollowed me'	'3people Unfollowed Me'
'for the last week'	    'For The Last Week'

'''

def solution(s):
    result=''
    some_list=[]                           # split 함수로 s 를 담을 빈 리스트 만듬
    s=s.title().split(' ')                 # 첫 문자만 대문자로 만든 다음 공백 하나를 띄어 리스트만들기
    for i in s:
        if i.isalpha():                    # 문단 하나가 전체 문자로 이루어져 있는지 확인
            some_list.append(i)            # 맞으면 리스트이 추가하고
            some_list.append(' ')          # 공백 추가
        else:
            i=i.lower()                    # 숫자가 있다면 전체 소문자화 하기
            some_list.append(i)            # 빈 리스트에 추가
            some_list.append(' ')          # 공백 추가
    some_list[-1]=''                       # 마지막에 추가된 공백을 제거
    result+=''.join(some_list)             # 문자열로 만들어서 반환
    return result
print(solution('3people unFollowed me'))


# 프로그래머스 개새끼들. 태케 진짜 좆같이 만들어버리네
# 이렇게 좆같이 바뀐 이유는 아마 s.title 이라는 메소드 때문일 가능성이 높음
# 메소드로 쉽게 풀수록 테케는 점점 더 복잡해짐을 명심하자.




'''
문제 설명
괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어

'()()' 또는 '(())()' 는 올바른 괄호입니다.
')()(' 또는 '(()(' 는 올바르지 않은 괄호입니다.

'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고,
올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.

제한 사항
문자열 s의 길이 : 100,000 이하의 자연수
문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.

입출력 예
s	        answer
'()()'	    true
'(())()'	true
')()('	    false
'(()('	    false

'''





def solution(s):
    answer=True
    some_list=[]                      # Queue의 원리를 이용한다.
    for i in s:
        if i=='(':                    # 문자열 s의 요소가 '('라면
            some_list.append(i)       # 빈 리스트에 추가해준다.
        else:
            try:
                some_list.pop()       # 문자열의 요소가 ')'라면 pop() 매소드로 리스트 안의 '('을 제거해준다.
            except:                   # ')'만 나올 수 있다. 그러면 바로 False 로 이동하게 하라.
                return False
    if len(some_list)==0:             # '(' 다음에 ')'이 나왔다는 증거로 리스트의 길이가 0이어야 한다.
        return answer                 # 0이라면 True 로 반환
    else:                             # 아니면 False 로 반환
        return False

print(solution(')))))'))



#  스택/ 큐의 원리를 응용해서 풀 수 있다.
# 완전한 함수가 완성된다는 걸 증명하기 위해 리스트의 길이가 0인 조건을 내세운 건 대단하다.





'''

문제 설명
0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 
순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

제한 사항
numbers의 길이는 1 이상 100,000 이하입니다.
numbers의 원소는 0 이상 1,000 이하입니다.
정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.
입출력 예
numbers	            return
[6, 10, 2]      	'6210'
[3, 30, 34, 5, 9]	'9534330'
'''

def solution(num):
    num=list(map(str,num))
    num.sort(key=lambda x:x*3,reverse=True)
    return str(int(''.join(num)))

print(solution([6,9,23,4,5]))



# 내가 푼 문제 아님 - 정렬 알고리즘이랑은 거리가 있는 답이 나와서 당황스럽다.
# 자리값을 서로 비교하기 위해 lambda 를 썼고 num 의 길이가 1000 이하이므로 문자형으로 캐스팅한 num 을 1000의 자리까지 비교
# 마지막 줄은 [0,0,0,0]에서 0이 나오게 하기 위한 줄이라고 한다.
# 봐도 이해가 잘 안들어오는 코딩은 베껴도 전혀 기쁘지 않다.


'''
문제 설명
H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다.
위키백과1에 따르면, H-Index는 다음과 같이 구합니다.

어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고
나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.

어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때,
이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.

제한사항
과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.
논문별 인용 횟수는 0회 이상 10,000회 이하입니다.

입출력 예
citations	    return
[3, 0, 6, 1, 5]	    3

'''

def solution(citations):

    answer = 0
    max_val = max(citations)       # h-index 는 인용 횟수 배열의 최대값 이하이다.


    for i in range(len(citations)-1):
        for j in range(i+1,len(citations)):
            if citations[i]>citations[j]:
                citations[i],citations[j]=citations[j],citations[i]    # 내림차순 선택 정렬

    while (True):                   # 무한루프
        over_cnt = 0                # h 값을 배열 내에서 맞추기 위해서 변수 지정
        for b in citations:
            if b >= max_val:        # 최대값 이상의 요소가 있다면
                over_cnt += 1       # 변수 1 증가
                '''
                어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고
                나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.
                '''
        if over_cnt >= max_val and len(citations) - over_cnt <= max_val:
            return max_val     # 같다면 반환

        max_val -= 1           # 아니면 최대값을 1씩 감소

    return answer

print(solution([3,0,6,1,5]))



# h-index 라는 용어가 낯설어서 처음에 문제 자체가 이해가 안됨.
# 게다가 이 문제도 정렬 알고리즘과 거리가 있다. 정렬 알고리즘의 과정 속에서 답을 도출하는 것이 아니라 정렬이 부수적으로 전락
# 정렬 부분은 알고리즘 방식을 그대로 가져와서 참조한 것이다. 원래, sorted 로도 가능하다.





'''
문제 설명
S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다.
그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다.
그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다.
예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때,
최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

제한사항
d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

입출력 예
d	        budget	result
[1,3,2,5,4]	9	    3
[2,2,3,3]	10	    4

입출력 예 설명
입출력 예 #1
각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다.
만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다.
항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다.
위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.
3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

입출력 예 #2
모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.
'''


def solution(d,budget):
    answer=0        
    d.sort()              # 섞인 숫자를 정렬하여 조건에 맞게 도출하게끔 하는 빌드어 작업
    depart=[]             # 빈 리스트 추가 (stack 응용)


    for i in d:            
        depart.append(i)           # depart 리스트에 부서별 지원 금액을 추가 
        if sum(depart)<=budget:    # 리스트의 총 합이 예산을 초과하지만 않으면
            answer+=1              # 지원이 가능하다는 의미이므로 초기값에 1씩 추가.


    return answer

print(solution([4,6,2,3],10))


# budget -= d[i] 는 사용하지 않았다. 예산은 그대로 두고 부서지원 금액의 합과 그대로 비교하게 두는 것이 효율적이라 생각했다.
# 다만 시간이 좀 느리게 간다. 좀 무거운 코딩인것은 확실
