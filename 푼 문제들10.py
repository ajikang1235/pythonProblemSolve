'''
문제 설명
자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.

조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.
조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.
조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.
예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.

자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.

제한 사항
n은 1,000,000 이하의 자연수 입니다.

입출력 예
n	result
78	83
15	23


'''

def solution(n):
    answer=0
    a=str(bin(n))                       # count 를 위해 str 로 2진법 함수를 캐스팅
    a_1=int(a,2)                        # while 문 안의 비교를 위해 2진법을 다시 숫자로 만든 변수 활용 (n과 같음)

    while n:                            # 자연수니 무조건 참일 것이다.
        n+=1                            # 1씩 더하여 조건에 맞게끔 형성, 전의 n과 뒤의 n을 비교하기 위한 장치
        b=str(bin(n))                   # 위의 과정과 동일
        b_1=int(b,2)
        if b_1>a_1 and a.count('1')==b.count('1'):  # n 보다 큰 자연수이며 1의 갯수가 같은 숫자 구하기위한 조건
            answer+=b_1
            return answer

print(solution(15))

# 이 문제는 bin() 함수를 통해 쉽게 풀 수 있는데, 쓸데없는 변수가 조금 들어갔다.
# bin() 함수 또한 캐스팅하지 않고 count() 메소드로 구하는 것이 가능해진다.


'''
문제 설명
Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 
자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.

1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.

제한사항
n은 10,000 이하의 자연수 입니다.


입출력 예
n	result
15	4
'''



def numArray(n):

    answer = 1                            # n이 하나있어도 1 추가
    for i in range(1, n // 2 + 1):        # n의 반 값에 1 하나 추가한것 만으로도 길이를 구할수 있다.
        cnt = 0                           # 합계를 구할 변수 설정
        for j in range(i, n + 1):         # 1부터 n 까지의 숫자구하고
            cnt += j                      # 합계를 더해나간다.
            if cnt == n:                  # 합계가 n 과 같다면
                answer += 1               # answer 에 1 추가
                break
            elif cnt > n:                 # 합계가 n 이상이 될 수는 없으니 break
                break
            else:
                continue

# 완전 탐색과 비슷한 방법이라고 한다.
# for 문이 좀 많아서 리스트로 1차 정리했는데 그러면 코드가 더 복잡해지기만 한다.
# 무조건 하나로 치환한다는게 문제 해결에 도움이 되지는 않을 수 있다.


'''
0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.

x의 모든 0을 제거합니다.
x의 길이를 c라고 하면, x를 c를 2진법으로 표현한 문자열로 바꿉니다.

예를 들어, x = "0111010"이라면, x에 이진 변환을 가하면 x = "0111010" -> "1111" -> "100" 이 됩니다.

0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 '1'이 될 때까지 계속해서 s에 이진 변환을 가했을 때,
이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.

입출력 예
s	            result
"110010101001"	[3,8]
"01110"	        [3,3]
"1111111"	    [4,1]

입출력 예 #1

110010101001이 1이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
회차	이진 변환 이전	제거할 0의 개수	0 제거 후 길이	이진 변환 결과
1	110010101001	6	            6	            110
2	110	            1	            2	            10
3	10	            1	            1	            1
3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다

입출력 예 #2

01110이 1이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.
회차	이진 변환 이전	제거할 0의 개수	0 제거 후 길이	이진 변환 결과
1	01110	2	3	11
2	11	0	2	10
3	10	1	1	1
3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.

주의 : '11'이라도 '1'로 바꿀 때까지 계속 바꿔야 한다.

'''


def solution(s):
    answer = []

    cnt1=0
    cnt2=0
    while s:                                           # 시간 많이 잡아먹지만 그래도 이게 낫다. 반복문 while 을 지정.
        zero_cnt=len(s)-s.count('0')                   # 아진으로 변한하기 전의 숫자는 여기서 완성한다. 전체 문자에서 0만 뺀 수
        cnt1+=s.count('0')                             # '0' 이 있는 갯수만 추가
        s.replace('0','')                              # '0'을 replace 함수로 제거
        s=bin(zero_cnt).replace('0b','')               # 처음 생성한 숫자를 이진변환,앞의 '0b' 도 제거
        if s != '1':                                   # '1'이 아니라면
            cnt2+=1                                    # 될 때까지 cnt2 에 1을 추가
            continue
        else:                                          # 1이 맞다면
            cnt2 += 1                                  # 다 완료되었으니 1을 더 추가하고 빈 리스트에 변수값 삽입
            answer.append(cnt2)
            answer.append(cnt1)
            break


    return answer


print(solution('110010101001'))

#  문제 이해도부터 풀이까지 어렵지 않은 문제.
# 테케가 추가된다면 상당히 까다로울 것이다. 처음에 '0'이 완전히 없는 것으로 파악했다가
# '1'로 되어야 되는 과정까지임을 알고, 다시 고쳐 풀었다.




'''
문제 설명
피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

F(2) = F(0) + F(1) = 0 + 1 = 1
F(3) = F(1) + F(2) = 1 + 1 = 2
F(4) = F(2) + F(3) = 1 + 2 = 3
F(5) = F(3) + F(4) = 2 + 3 = 5
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

제한 사항
* n은 1이상, 100000이하인 자연수입니다.

입출력 예
n	return
3	2
5	5

입출력 예 설명
피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.
'''


def solution(n):
    answer = [0] * (n+1)                       # 0번째 인덱스는 0으로 남기고 n 만큼 공간 확보를 위해 n+1 을 곱한다.
    answer[1] = 1                              # 1번째 인덱스는 1로 남긴다.
    for i in range(2, n+1):                    # 2부터 n+1 까지 반복시켜주어
        answer[i] = answer[i-1] + answer[i-2]  # 파보나치 수열에 맞게 자리값을 구한다.
    return answer[n]%1234567                   # 자리값에 맞는 수를 1234567로 나눈다.

# [0] * [n+1]
# 이 문제는 피보나치 수열의 결과값을 1234567로 나누는 것이 아니라 수열이 진행될 때 마다 1234567로 나누는 것이라고 한다.
# 따라서 숫자가 너무 커지게 되면 컴퓨터의 x86 의 4byte 내에서 처리할 수 있는 연산 값 2의 32 제곱을 넘는다.
# 이러한 전제가 있어야 위의 문제와 같이 접근할 수 있다.
# 숫자가 아니라, 컨테이너인 리스트를 만들어 연산 처리의 과부하를 방지한다.
# 만약 숫자가 너무 커짐을 우려하는 문제가 나온다면 컨테이너의 응용을 고려해보는 게 좋을 것 같다.
# 파보나치 수열은 동적 계획법을 따르고 있다.


'''
비밀지도
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를
확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(" ) 또는벽(#") 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자.
지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

입력 형식
입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.

1 ≦ n ≦ 16
arr1, arr2는 길이 n인 정수 배열로 주어진다.
정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.
출력 형식
원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.

입출력 예제
매개변수	값
n	5
arr1	[9, 20, 28, 18, 11]
arr2	[30, 1, 21, 17, 28]
출력	["#####","# # #", "### #", "# ##", "#####"]
매개변수	값
n	6
arr1	[46, 33, 33 ,22, 31, 50]
arr2	[27 ,56, 19, 14, 14, 10]
출력	["######", "### #", "## ##", " #### ", " #####", "### # "]
'''


def solution(n,arr1,arr2):
    answer=[]

    for i,j in zip(arr1,arr2):
        bin_str=str(bin(i|j)[2:])            # |라는 비트 연산자 사용하여 '0b' 다음의 이진수비교
        bin_str=bin_str.rjust(n,'0')         # 오른쪽 정렬후 문자길이만큼 '0' 을 채워준다.
        bin_str=bin_str.replace('1','#')     # '1'은 '#'으로
        bin_str=bin_str.replace('0',' ')     # '0'은 ' '(공백) 으로
        answer.append(bin_str)               # 빈 리스트에 추가

    return answer

print(solution(5,[9,20,28,18,11],[30,1,21,17,28]))


# 비트 연산자 | 는 2개의 진수를 or 로 비교하여 값을 정의내린다.
# rjust 는 오른쪽으로 정렬하게끔 도와주는 함수. 자릿


'''
문제 설명

점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다.
학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다.
예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다.
체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.

전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost,
여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때,
체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.


제한사항
전체 학생의 수는 2명 이상 30명 이하입니다.
체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며,
남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.

입출력 예
n	lost	reserve	    return
5	[2, 4]	[1, 3, 5]	5
5	[2, 4]	[3]	        4
3	[3]	    [1]	        2

입출력 예 설명
예제 #1
1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.

예제 #2
3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.
'''


def solution(n,lost,reverse):

    set_reverse=set(reverse)-set(lost)      # 여벌을 가져온 학생이 도난당할 수 있는 상황 가정시 중복여부를 제거
    set_lost=set(lost)-set(reverse)         # 빌려줄 수 있는 학생만 추론해내기 위해서 (전처리 과정)

    for i in set_reverse:                   # 빌려온 학생 중에서
        if i-1 in set_lost:                 # 왼쪽 값부터 처리를 해야하기 때문에 해당하는 값이 여벌복 학생에 있다면
            set_lost.remove(i-1)            # 옷을 빌려줄 수 있으므로 제거해주고
        elif i+1 in set_lost:               # 왼쪽에 없다면 오른쪽 값에서 찾아
            set_lost.remove(i+1)            # 해당하는 값이 있으면 제거해준다.

    return n-len(set_lost)                  # 끝까지 옷을 못 빌려온 학생이 set_lost 에 남게되므로 전체 학생수에서 빼준다.


print(solution(5,[2,4],[3]))


# 탐욕법 알고리즘에서 그나마 쉬운 문제라고 한다.
# 핵심은 문제의 어느 부분에서 어느 부분까지 전처리 연산을 하여 최적의 값을 찾아내는지를 탐구하는 것이다.
# 탐욕법의 사용빈도도 작은 편이 아니니 for 문을 쓰기 전에 어느 부분의 데이터를 전처리 연산할 것인지를 결정해야 한다.
