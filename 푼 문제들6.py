'''
배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다.
이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다.
단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,

arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.
arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.
배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.

제한사항
배열 arr의 크기 : 1,000,000 이하의 자연수
배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수

입출력 예
arr	            answer
[1,1,3,3,0,1,1]	[1,3,0,1]
[4,4,4,3,3]	    [4,3]
'''


def solution(arr):
    answer = []  # 빈 리스트 하나 생성해주고
    answer.append(arr[0])  # 첫번 째 자리 값은 디폴트로 지정해준다.
    for i in range(1, len(arr)):  # 1에서 총 길이까지의 인덱스 번호를 구하고,
        if arr[i] != arr[i - 1]:  # 반복되는 인덱스 번호와 그 번호의 -1 의 자리값의 원소가 동일하지 않는다면
            answer.append(arr[i])  # 빈 리스트에 추가해준다.

    return answer


print(solution([4, 4, 4, 3, 3]))

# 연속되는 자리값만을 제거하다 보니 첫 번째 예시와 같은 경우는 [3,0,1,1]이 나와버렸다.
# 자리값에 대한 이해가 좀 더 필요하다. 보통 2~3가지 루틴이 막힐 때 능지가 처참해진다.


'''
행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다.
2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.

제한 조건
행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.

입출력 예
arr1	        arr2	        return
[[1,2],[2,3]]	[[3,4],[5,6]]	[[4,6],[7,9]]
[[1],[2]]	    [[3],[4]]	    [[4],[6]]

'''


def solution(arr1, arr2):
    answer = [[]]
    for i in range(0, len(arr1)):  # 2차원 리스트의 행을 출력해준다.
        answer.append([])  # 행이 반복되어 오는 자리에 빈 리스트를 추가해준다.
        for j in range(0, len(arr1[i])):  # 열을 출력해준다.
            answer[i].append(arr1[i][j] + arr2[i][j])  # 행에 해당하는 자리에 각 배열의 행과 열에 해당하는 인덱스를 축출
    answer.remove(answer[-1])  # 행이 반복될 때마다 추가되는 빈 리스트를 제거해준다.
    # 항상 마지막 자리에 오기 때문에, 맨끝에 있는 인덱스 자리를 빼주면 된다.

    return answer  # 짠!


print(solution([[1, 2], [2, 3]], [[3, 4], [5, 6]]))

# arr1[i][j] 2차원 리스트의 행과 열을 출력해주는 것이다. for문을 2번 사용해서 출력해주면 된다. 기억해두자.
# for i in range(0,len(arr1)):    2차원 리스트의 행을 출력해주는 반복문.
# for j in range(0,len(arr1[i])): 2차원 리스트의 열을 출력해주는 반복문.


'''
문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다.
예를 들어 strings가 [sun, bed, car]이고 n이 1이면 각 단어의 인덱스 1의 문자 u, e, a로 strings를 정렬합니다.

제한 조건
strings는 길이 1 이상, 50이하인 배열입니다.
strings의 원소는 소문자 알파벳으로 이루어져 있습니다.
strings의 원소는 길이 1 이상, 100이하인 문자열입니다.
모든 strings의 원소의 길이는 n보다 큽니다.
인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.

입출력 예
strings	                n	return
['sun', 'bed', 'car']	1	['car', 'bed', 'sun']
['abce', 'abcd', 'cdx']	2	['abcd', 'abce', 'cdx']

입출력 예 설명
입출력 예 1
sun, bed, car의 1번째 인덱스 값은 각각 u, e, a 입니다. 이를 기준으로 strings를 정렬하면 [car, bed, sun] 입니다.

입출력 예 2
abce와 abcd, cdx의 2번째 인덱스 값은 c, c, x입니다. 따라서 정렬 후에는 cdx가 가장 뒤에 위치합니다.
abce와 abcd는 사전순으로 정렬하면 abcd가 우선하므로, 답은 [abcd, abce, cdx] 입니다.
'''


def solution(strings, n):
    return sorted(strings, key=lambda x: (x[n:n + 1], x))


print(solution(['abce', 'abcd', 'cdx'], 2))

# lambda 함수는 어떤 인덱스를 기준으로 비교를 하는 데 쓰이는 함수이다. x는 주로 리스트를 치환하는 것을 뜻한다.
# 여기에는 첫 번째 기준으로 x: x[n] 의 인덱스를 토대로 비교하고,
# 그 다음 인덱스되는 문자가 같을 시 +1 되는 자리의 결과값을 x 전체와 비교해서 정렬해준다.
# lambda 함수는 쉽게 눈에 들어오는 함수가 아니니 잘 보도록 하자. 특히, 함수 안에 2개의 기준이 입력가능하다는 것도 말이다.


'''
문제 설명
문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다.
각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.

제한 사항
문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.
첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.

입출력 예
s	                return
'try hello world'	'TrY HeLlO WoRlD'

입출력 예 설명
'try hello world'는 세 단어 'try', 'hello', 'world'로 구성되어 있습니다.
각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 'TrY', 'HeLlO', 'WoRlD'입니다.
따라서 'TrY HeLlO WoRlD' 를 리턴합니다.
'''


def solution(s):
    charlist = ""
    idx = 0  # 인덱스 변수를 입력해준다.
    for i in s:
        if i.isalpha():  # 모든 문자가 문자로 이루어져 있으면, 대문자/ 소문자 변경하고. 공백일시 공백추가
            idx += 1  # 인덱스 하나씩 추거
            if idx % 2 != 0:  # 인덱스 자리가 홀수/짝수인지 가리기
                charlist += i.upper()  # 문장의 앞뒤에 공백이 있으므로 홀수일시 대문자
            else:
                charlist += i.lower()  # 짝수일시 소문자
        else:
            idx = 0
            charlist += ' '  # 인덱스 자리값이 공백ㅇ면 공백 추가
            continue  # 반복하기

    return charlist


print(solution('try hello world'))

# 문장의 앞 뒤에 공백이 있다는 것을 가정해야 한다. 출력물만 보면, 그걸 알아차리기가 힘들다
# 1.문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.
# 2.각 단어는 하나 이상의 공백문자로 구분되어 있습니다.
# 1,2 번의 전제에 따르면, 단어 별에는 적어도 하나의 공백이 있고, 단어가 끝날때마다 공백을 추가해줘야 한다.
# 그래서 split()함수의 사용이 어려운 측면이 있다.



'''
문제 설명
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다.
수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때,
가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한 조건
시험은 최대 10,000 문제로 구성되어있습니다.
문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

입출력 예
answers	    return
[1,2,3,4,5]	[1]
[1,3,2,4,2]	[1,2,3]

입출력 예 설명
입출력 예 #1

수포자 1은 모든 문제를 맞혔습니다.
수포자 2는 모든 문제를 틀렸습니다.
수포자 3은 모든 문제를 틀렸습니다.
따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.

입출력 예 #2

모든 사람이 2문제씩을 맞췄습니다.
'''


def solution(answers):
    answer=[]
    man1=[1,2,3,4,5]                           # 패턴 정리
    man2=[2,1,2,3,2,4,2,5]
    man3=[3,3,1,1,2,2,4,4,5,5]

    len_man1=len(man1)                        # ?
    len_man2=len(man2)
    len_man3=len(man3)

    right_1=0                                # 많이 맞은 사람값 초기화 생성.
    right_2=0
    right_3=0

    for i in range(len(answers)):
        if man1[i%len_man1]==answers[i]:    #  [i%len_man1] 이것이 아직 이해가 안감.
            right_1+=1                      #  맞은 갯수를 값에다 추가한다.

        if man2[i%len_man2]==answers[i]:
            right_2+=1

        if man3[i%len_man3]==answers[i]:
            right_3+=1

    best_man=max(right_1,right_2,right_3)   # 최대한 많이 맞은 사람 구하기

    if best_man==right_1:                   # 1번 수포자가 많이 맞았다면 answer 에 1 추가
        answer.append(1)
    if best_man==right_2:                   # 2번 수포자가 많이 맞았다면 answer 에 2 추가
        answer.append(2)
    if best_man==right_3:                   # 3번 수포자가 많이 맞았다면 answer 에 3 추가
        answer.append(3)

    answer=sorted(answer)                   # 오름차순 정렬
    return answer

print(solution([1,3,2,4,2,5,1,2,3,4,5,1,1,4,4]))



# [i%변수] 반복문안에서 인덱스를 불러일으킬시, 변수를 활용하는 방법인데, 아직 변수를 효과적으로 사용하는 방법에는 익숙치 않아, 잘 이해 안됨.
# enumerate 함수는 사용빈도가 잘 안 늘고 있다. 어떻게 사용할지 감이 잡히지 않는다.